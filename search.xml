<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS设计模式-状态模式]]></title>
    <url>%2F2019%2F03%2F17%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是使用if…else来控制eg: 红绿灯 收藏/未收藏核心： 状态和主体分离 UML类图 代码演示1234567891011121314151617181920212223242526272829303132333435363738class State &#123; constructor(color) &#123; this.color = color &#125; handle(context) &#123; console.log(`turn to $&#123;this.color&#125; light`) context.setState(this) &#125;&#125;class Context &#123; constructor() &#123; this.state = null &#125; setState(state) &#123; this.state = state &#125; getState() &#123; return this.state &#125;&#125;// 测试代码let context = new Context()let greed = new State('greed')let yellow = new State('yellow')let red = new State('red')// 绿灯亮了greed.handle(context)console.log(context.getState())// 黄灯亮了yellow.handle(context)console.log(context.getState())// 红灯亮了red.handle(context)console.log(context.getState()) 场景 有限状态机 写一个简单的Promise有限状态机 有限个状态，以及在这些状态间的变化 如交通信号灯 使用开源lib :javascript-state-machine123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;有限状态机&lt;/p&gt; &lt;button id="btn"&gt;&lt;/button&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="./03-javascript-state-machine.js"&gt;&lt;/script&gt; &lt;script&gt; // 状态机模型 var fsm = new StateMachine(&#123; init: '收藏', // 初始状态，待收藏 transitions: [ &#123; name: 'doStore', from: '收藏', to: '取消收藏' &#125;, &#123; name: 'deleteStore', from: '取消收藏', to: '收藏' &#125; ], methods: &#123; // 执行收藏 onDoStore: function () &#123; alert('收藏成功') updateText() &#125;, // 取消收藏 onDeleteStore: function () &#123; alert('已取消收藏') updateText() &#125; &#125; &#125;) var $btn = $('#btn') // 点击事件 $btn.click(function () &#123; if (fsm.is('收藏')) &#123; fsm.doStore(1) &#125; else &#123; fsm.deleteStore() &#125; &#125;) // 更新文案 function updateText() &#123; $btn.text(fsm.state) &#125; // 初始化文案 updateText() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 写一个PromisePromise 三个状态 pending 准备 fullfilled 成功 （执行resolve) rejected 失败 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script src="./03-javascript-state-machine.js"&gt;&lt;/script&gt; &lt;script&gt; // 模型 var fsm = new StateMachine(&#123; init: 'pending', transitions: [ &#123; name: 'resolve', from: 'pending', to: 'fullfilled' &#125;, &#123; name: 'reject', from: 'pending', to: 'rejected' &#125; ], methods: &#123; // 成功 onResolve: function (state, data) &#123; // 参数：state - 当前状态示例; data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn =&gt; fn()) &#125;, // 失败 onReject: function (state, data) &#123; // 参数：state - 当前状态示例; data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn =&gt; fn()) &#125; &#125; &#125;) // 定义 Promise class MyPromise &#123; constructor(fn) &#123; this.successList = [] this.failList = [] fn(() =&gt; &#123; // resolve 函数 fsm.resolve(this) &#125;, () =&gt; &#123; // reject 函数 fsm.reject(this) &#125;) &#125; then(successFn, failFn) &#123; this.successList.push(successFn) this.failList.push(failFn) &#125; &#125; // 测试代码 function loadImg(src) &#123; const promise = new MyPromise(function (resolve, reject) &#123; var img = document.createElement('img') img.onload = function () &#123; resolve(img) &#125; img.onerror = function () &#123; reject() &#125; img.src = src &#125;) return promise &#125; var src = 'http://www.imooc.com/static/img/index/logo_new.png' var result = loadImg(src) console.log(result) result.then(function (img) &#123; console.log('success 1') &#125;, function () &#123; console.log('failed 1') &#125;) result.then(function (img) &#123; console.log('success 2') &#125;, function () &#123; console.log('failed 2') &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设计原则验证 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-迭代器模式]]></title>
    <url>%2F2019%2F03%2F16%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 顺序访问一个集合 使用者无需知道集合的内部结构（封装）迭代器模式通常都是对一个数组，集合等进行访问，迭代器的设计是为了封装一个方法，可以对多种数据类型进行访问。 代码说明123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;p&gt;jquery each&lt;/p&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; var arr = [1, 2, 3] var nodeList = document.getElementsByTagName('p') var $p = $('p') // 要对这三个变量进行遍历，需要写三个遍历方法 // 第一 arr.forEach(function (item) &#123; console.log(item) &#125;) // 第二 var i, length = nodeList.length for (i = 0; i &lt; length; i++) &#123; console.log(nodeList[i]) &#125; // 第三 $p.each(function (key, p) &#123; console.log(key, p) &#125;) // 如何能写出一个方法来遍历这三个对象呢 function each(data) &#123; var $data = $(data) $data.each(function (key, p) &#123; console.log(key, p) &#125;) &#125; each(arr) each(nodeList) each($p) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; UML类图 UML类图代码演示12345678910111213141516171819202122232425262728293031323334class Iterator &#123; constructor(conatiner) &#123; this.list = conatiner.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;// 测试代码let container = new Container([1, 2, 3, 4, 5])let iterator = container.getIterator()while(iterator.hasNext()) &#123; console.log(iterator.next())&#125; 场景 jQuery each ES6 IteratorjQuery each123456789function each(data) &#123; var $data = $(data) $data.each(function (key, p) &#123; console.log(key, p) &#125;) &#125; each(arr) each(nodeList) each($p) ES6 IteratorES6 Iterator为何存在？ ES6语法中，有序集合的数据类型已经有很多 Array Map Set String TypedArray arguments NodeList Generator(慢慢被ES7 async await替代） 需要有一个统一的遍历接口来遍历多有数据类型 （注意，object不是有序集合，可以用Map来代替) ES6 Iterator是什么？ 以上数据类型，都有[Sysbol.iterator]属性 属性值是函数，执行函数返回一个迭代器 for…of的出现 具体教程可以看阮一峰ES6ES6 迭代器演示123456789101112131415161718192021222324252627let arr = [1, 2, 3, 4]let nodeList = document.getElementsByTagName('p')let m = new Map()m.set('a', 100)m.set('b', 200)function each(data) &#123; 生成遍历器 let iterator = data[Symbol.iterator]() console.log(iterator.next()) // 有数据时返回 &#123;value: 1, done: false&#125; console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) // 没有数据时返回 &#123;value: undefined, done: true&#125; let item = &#123;done: false&#125; while (!item.done) &#123; item = iterator.next() if (!item.done) &#123; console.log(item.value) &#125; &#125;each(arr)each(nodeList)each(m) 执行结果 `javascript// Symbol.iterator 并不是人人都知道// 也不是每个人都需要封装一个each方法// 因此有了 for...of语法// data需要包含Symbol.iterator这个属性才可以function each(data) { for (let item of data) { console.log(item) }} each(arr)each(nodeList)each(m) 设计原则验证 迭代器对象和目标对象分离 迭代器将使用者与目标对象隔离开 符合开放封闭原则 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-观察者模式]]></title>
    <url>%2F2019%2F03%2F12%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式是前端设计模式的核心 介绍 发布 &amp; 订阅 一对多什么是发布 &amp; 订阅？ 我说好了一键事情，等着别人来做。 比如，我躺在家里，订了一份外卖，然后等着，会有人来给你触发。一对多就像一个拍卖品一样，同时可以有多个人观察它。 UML类图左侧是Observer，就是观察者，它有一个update方法，当观察者需要被触发的时候执行update。右侧是主题，主题可以绑定多个观察者，放在observers里面。主题可以获取状态（getState()),也可以设置状态（setState())当状态设置完成后，他会触发所有的观察者（notifyAllObservers()),触发所有观察者里面的update方法。观察者定义好以后，它就等待被更新，等待被触发，当然，前提是它已经定义好了。注意一对多，主题是一个，但是观察者可能是多个。可能还不是很理解，可以看看下面代码演示，仔细看几遍，比较容易理解。 代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344// 主题，接收状态变化，触发每个观察者class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; attach(observer) &#123; this.observers.push(observer) &#125; notifyAllObservers() &#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125;&#125;// 观察者，等待被触发class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`) &#125;&#125;// 测试代码let s = new Subject()let o1 = new Observer('o1', s)let o2 = new Observer('o2', s)let o3 = new Observer('o3', s)s.setState(1)s.setState(2)s.setState(3) 运行结果如下图 场景 网页事件绑定 Promise jQuery callbacks nodejs 自定义事件 网页事件绑定12345678910111213&lt;button id="btn1"&gt;btn&lt;/button&gt;&lt;script&gt; $('#app').click(function()&#123; console.log(11); &#125;) $('#app').click(function()&#123; console.log(22); &#125;) $('#app').click(function()&#123; console.log(33); &#125;)&lt;/script&gt;// 每次点击都会打印 11 22 33 Promise12345678910var src = 'http://www.imooc.com/static/img/index/logo_new.png'var result = loadImg(src)console.log(result)result.then(function (img) &#123; console.log('success 1')&#125;, function () &#123; console.log('failed 1')&#125;)// then就是一个观察者，等待前一个处理完成 Jquery $.Callbacks()123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;jQuery callbacks&lt;/p&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; // 自定义事件，自定义回调 var callbacks = $.Callbacks() // 注意大小写 callbacks.add(function (info) &#123; console.log('fn1', info) &#125;) callbacks.add(function (info) &#123; console.log('fn2', info) &#125;) callbacks.add(function (info) &#123; console.log('fn3', info) &#125;) callbacks.fire('gogogo') callbacks.fire('fire') &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; nodejs 自定义事件12345678910111213const EventEmitter = require('events').EventEmitterconst emitter1 = new EventEmitter()emitter1.on('some', () =&gt; &#123; // 监听 some 事件 console.log('some event is occured 1')&#125;)emitter1.on('some', () =&gt; &#123; // 监听 some 事件 console.log('some event is occured 2')&#125;)// 触发 some 事件emitter1.emit('some') 继承12345678910111213141516const EventEmitter = require('events').EventEmitter// 任何构造函数都可以继承 EventEmitter 的方法 on emitclass Dog extends EventEmitter &#123; constructor(name) &#123; super() this.name = name &#125;&#125;var simon = new Dog('simon')simon.on('bark', function () &#123; console.log(this.name, ' barked')&#125;)setInterval(() =&gt; &#123; simon.emit('bark')&#125;, 500) 12345678910var fs = require('fs')var readStream = fs.createReadStream('./data/file1.txt') // 读取文件的 Streamvar length = 0readStream.on('data', function (chunk) &#123; length += chunk.toString().length&#125;)readStream.on('end', function () &#123; console.log(length)&#125;) 12345678910111213141516const EventEmitter = require('events').EventEmitter// 任何构造函数都可以继承 EventEmitter 的方法 on emitclass Dog extends EventEmitter &#123; constructor(name) &#123; super() this.name = name &#125;&#125;var simon = new Dog('simon')simon.on('bark', function () &#123; console.log(this.name, ' barked')&#125;)setInterval(() =&gt; &#123; simon.emit('bark')&#125;, 500) 12345678910var fs = require('fs')var readStream = fs.createReadStream('./data/file1.txt') // 读取文件的 Streamvar length = 0readStream.on('data', function (chunk) &#123; length += chunk.toString().length&#125;)readStream.on('end', function () &#123; console.log(length)&#125;) 1234567891011121314var readline = require('readline');var fs = require('fs')var rl = readline.createInterface(&#123; input: fs.createReadStream('./data/file1.txt')&#125;);var lineNum = 0rl.on('line', function(line)&#123; lineNum++&#125;);rl.on('close', function() &#123; console.log('lineNum', lineNum)&#125;); 其他场景 nodejs中：处理http请求，多进程通讯 vue和react组件生命周期触发 vue watch nodejs 处理http请求1234567891011121314151617181920212223242526var http = require('http')function serverCallback(req, res) &#123; var method = req.method.toLowerCase() // 获取请求的方法 if (method === 'get') &#123; &#125; if (method === 'post') &#123; // 接收 post 请求的内容 var data = '' req.on('data', function (chunk) &#123; // “一点一点”接收内容 console.log('chunk', chunk.toString()) data += chunk.toString() &#125;) req.on('end', function () &#123; // 接收完毕，将内容输出 console.log('end') res.writeHead(200, &#123;'Content-type': 'text/html'&#125;) res.write(data) res.end() &#125;) &#125; &#125;http.createServer(serverCallback).listen(8081) // 注意端口别和其他 server 的冲突console.log('监听 8081 端口……') 设计原则验证 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-外观模式]]></title>
    <url>%2F2019%2F03%2F12%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是外观模式 本段内容来自于 JAdam博客 有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 其实本篇要说的这个设计模式就和这很有关系，由于当投资者自己买股票时，由于众多投资者对众多股票的联系太多，反而不利于操作，这在软件中就成为耦合性太高，而有了基金后，就变成众多用户只和基金打交道，关心基金的上涨和下跌，而实际上的操作确是基金经理人与股票和其它投资产品打交道，这就是外观模式。 介绍 为子系统中的一组接口提供了一个高级接口 使用者使用这个高级接口看完后应该有一点印象，在看看这张图片就理解了如果没有这个高级接口，我们的代码链接可能很混乱难维护。外观模式在结合业务的场景中很常用。UML类图场景下面的列子就是一种简单的外观模式1234567891011function bindEvent(elem, type, selector, fn) &#123; if ( fn == null) &#123; fn = selector selector = null &#125; // *****&#125;// 调用bindEvent(elem, 'click', '#div1', fn)bindEvent(elem, 'click', fn) 设计原则验证不符合单一职责原则和开放封闭原则，因此要注意谨慎使用，不可滥用 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-代理模式]]></title>
    <url>%2F2019%2F03%2F09%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 使用者无权访问目标对象 中间加代理，通过代理做授权和控制比如说公司的内网，当我们在家的时候也是需要一个代理才能连接访问内网的信息。示例 科学上网，访问 github.com 明星的经纪人 （大多数情况下咱们不可能直接联系明星） UML类图代码说明12345678910111213141516171819202122232425class ReadImg &#123; constructor(filename) &#123; this.filename = filename; this.loadFromDisk() //初始化即从硬盘中加载， 模拟 &#125; display() &#123; console.log('display... ' + this.filename); &#125; loadFromDisk() &#123; console.log('loading... ' + this.filename); &#125;&#125;class ProxyImg &#123; constructor(filename)&#123; this.realImg = new ReadImg(filename); &#125; display() &#123; this.realImg.display(); &#125;&#125;// testlet proxyImg = new ProxyImg("1.png");proxyImg.display(); 场景 网页事件代理(事件委托） Jquery $.proxy ES6 Proxy事件委托代码实现123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;前端设计模式 - 代理模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;aaa&lt;/p&gt; &lt;p&gt;bbb&lt;/p&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;p&gt;ddd&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const appDom = document.querySelector("#app"); appDom.addEventListener("click", (e)=&gt;&#123; const target = e.target; if(target.nodeName="P")&#123; console.log(target,target.innerHTML) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; $.proxy本示例不考虑es6箭头函数解决this指向问题，假设我们维护的还是一个用Jquery的老项目。1234567891011121314//正常的this使用$('#myElement').click(function() &#123; // 这个this是我们所期望的，当前元素的this. $(this).addClass('aNewClass');&#125;);//并非所期望的this$('#myElement').click(function() &#123; setTimeout(function() &#123; // 这个this指向的是settimeout函数内部，而非之前的html元素 $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 这时候通常做法是这样的1234567$('#myElement').click(function() &#123; var that = this; //设置一个变量，指向这个需要的this setTimeout(function() &#123; // 这个this指向的是settimeout函数内部，而非之前的html元素 $(that).addClass('aNewClass'); &#125;, 1000);&#125;); 但是，在使用了jquery框架的情况下， 有一种更好的方式，就是使用$.proxy函数。 jQuery.proxy(),接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context )语境。上面的例子使用这种方式就可以修改成:12345$('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); 明星经纪人1234567891011121314151617181920212223242526272829303132333435363738394041424344// 明星let star = &#123; // name和age可以返回，点化就需要经纪人代理给拦截了。 name: '张XX', age: 25, phone: '13910733521'&#125;// 经纪人let agent = new Proxy(star, &#123; get: function (target, key) &#123; if (key === 'phone') &#123; // 返回经纪人自己的手机号 return '18611112222' &#125; if (key === 'price') &#123; // 明星不报价，经纪人报价 return 120000 &#125; return target[key] &#125;, set: function (target, key, val) &#123; if (key === 'customPrice') &#123; if (val &lt; 100000) &#123; // 最低 10w throw new Error('价格太低') &#125; else &#123; target[key] = val return true &#125; &#125; &#125;&#125;)// 主办方去找明星的经纪人console.log(agent.name) // 经纪人返回明星的姓名console.log(agent.age) // 明星的姓名console.log(agent.phone) // 经纪人的点化，经纪人拦截了phone。console.log(agent.price) // 明星搞艺术，不谈钱，经纪人谈钱。// 想自己提供报价（砍价，或者高价争抢）agent.customPrice = 150000// agent.customPrice = 90000 // 报错：价格太低console.log('customPrice', agent.customPrice) 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则代理模式 VS 适配器模式 适配器模式： 提供一个不同的接口（比如不同版本的插座插口) 代理模式： 提供一模一样的接口代理模式 VS 装饰器模式 装饰器模式： 扩展功能，原有功能不变且可直接使用，扩展功能不冲突原有功能。 代理模式： 显示原有功能，但是经过限制或者阉割之后的 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程。 $.proxy 代码部分来自于浪漫小生博客]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-装饰器模式]]></title>
    <url>%2F2019%2F03%2F07%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 为对象添加新功能 不改变其原有的结构和功能和适配器模式不一样，适配器模式是原有的不能用了，而装饰器模式是原来的还能用，不过给增加一些功能。比如： 手机壳，用来给手机美观，保护，防滑等等 UML类图 代码演示123456789101112131415161718192021222324class Circle &#123; draw() &#123; console.log("画一个圆形"); &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle; &#125; draw() &#123; this.circle.draw(); this.setRedBorder(this.circle); &#125; setRedBorder(circle) &#123; console.log("设置红色边框") &#125;&#125;// 测试代码let circle = new Circle();circle.draw()let dec = new Decorator(circle);dec.setRedBorder(); 场景 ES7装饰器-babel可转换 core-decorators等第三方库常用装饰器ES7装饰器装饰类一个简单的demo123456789// 一个简单的demofunction testDec(target) &#123; target.isDec = "林海"&#125;@testDecclass Demo &#123;&#125;alert(Demo.isDec) 装饰类的原理12345678// 装饰器的原理@decoratorclass A &#123;&#125;//等同于class A &#123;&#125;A = decorator(A) || A; 可以加参数12345678910function testDec(isDec) &#123; return function(target)&#123; target.isDec = isDec; &#125;&#125;@testDec(true)class Demo &#123;&#125;alert(Demo.isDec) 我们来做一个常用的mixins混合装饰器，来把一个类里面属性和方法全部添加到另一个类上123456789101112131415function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125; &#125; const Foo = &#123; foo() &#123; alert('foo') &#125; &#125; @mixins(Foo) class MyClass &#123;&#125; let obj = new MyClass(); obj.foo() // 'foo' 装饰方法让某个方法只读，不能修改1234567891011121314151617181920212223242526function readonly(target, name, descriptor)&#123; // descriptor属性描述对象 （Object.defineProperty 会用到) // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor; &#125; class Person &#123; constructor() &#123; this.first = 'A' this.last = 'B' &#125; @readonly testname() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125; &#125; var p = new Person() console.log(p.testname()) p.testname = function () &#123;&#125; // 这里会报错，因为 name 是只读属性 一个打印日志装饰器123456789101112131415161718192021function log(target, name, descriptor) &#123; var oldValue = descriptor.value; // name 是修饰的方法名字 descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor; &#125; class Math &#123; @log add(a, b) &#123; return a + b; &#125; &#125; const math = new Math(); const result = math.add(2, 4); console.log('result', result); 装饰类的时候，一般主要是看target（装饰对象）第一个参数。装饰方法的时候，一般主要看的是descriptor（描述）第三个参数。 core-decorators 第三方开源 lib 提供常用的装饰器,比如readonly只读状态,autobind绑定this等 查阅文档： https://github.com/jayphelps/core-decorators 12// 首先安装npm install core-decorators --save 这里我们使用 core-decorators提供的deprecate(对装饰的方法在浏览器中提示已经废弃） 12345678910111213141516171819202122232425import &#123; deprecate &#125; from 'core-decorators';class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate('We stopped facepalming') facepalmHard() &#123;&#125; @deprecate('We stopped facepalming', &#123; url: 'http://knowyourmeme.com/memes/facepalm' &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details. 运行结果如下图： 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 对装饰器更多学习，可以看 阮一峰es6装饰器教程 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-适配器模式]]></title>
    <url>%2F2019%2F03%2F05%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 旧接口模式和使用者不兼容 中间加一个适配器转接口比如你去香港或者出国去一些国家，他们的插排接口和我们都不一样，我要充电不能直接用，这个时候就需要一个适配器来转换一下电压。 UML类图代码演示12345678910111213141516171819class Adaptee &#123; specificRequest() &#123; return "德国标准插头"; &#125;&#125;class Target &#123; constructor() &#123; this.adaptee = new Adaptee() &#125; request() &#123; let info = this.adaptee.specificRequest(); return `$&#123;info&#125; - 转换器 - 中国插头` &#125;&#125;// 测试let target = new Target();let res = target.request();console.log(res); 场景 封装旧接口 vue computed封装旧接口123456789101112// 自己封装的 ajax 使用方法如下ajax(&#123; url: '/getData', type: 'post', dataType: 'json', data: &#123; id: "123" &#125;&#125;).done(function()&#123;&#125;)// 但因为历史原因，代码中全都是：// $.ajax(&#123;...&#125;) 如果这时候不适用jquery了，手动去一个个替换$.ajax不靠谱，旧接口不兼容，这时候我们只需要一个适配器来封装旧接口来实现，而且以后的也还可以继续像Jquery使用123456// 做一层适配器var $ = &#123; ajax: function(options)&#123; return ajax(options); &#125;&#125; vue的计算属性也是一个适配器，这里我拿官网demo来展示下，可以仔细品味下1234567891011121314151617181920&lt;div id="app"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-工厂模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是工厂模式工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛 ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。属于三大设计类型中的创建型模式。 什么时候用工厂模式，使用场景等？ 将 new 操作单独封装 遇到 new 时，就要考虑是否该使用工厂模式。 示例 你去购买汉堡，直接点餐，取餐，不用自己亲手做。 商店要 ”封装” 做汉堡的工作，做好直接给买者。 工厂模式UML类图如下其中Creator是一个工厂，Product 是一个产品。一个Creator工厂有一个create方法，返回一个产品，可以理解为最简单的工厂模式。 代码演示1234567891011121314151617181920212223242526272829class Product &#123; constructor(name) &#123; this.name = name; &#125; init() &#123; alert("init"); &#125; fn1() &#123; alert("fn1"); &#125; fn2() &#123; alert("fn2"); &#125; &#125;class Creator &#123; create(name)&#123; return new Product(name); &#125;&#125;// 测试let creator = new Creator();let p = creator.create("p1");p.init();p.fn1();// 结果 弹出 init 111 结论： 我们通过Creator类提供的create方法来创建Product， 通过Creator工厂已经把真正的构造函数封装起来了，我们用的时候只需要知道Creator工厂的create方法可以产生一个实例，而不用去关心生成的实例是谁。 常见场景 Jquery - $(“div”) React.createElement Vue 异步组件 1 Jquery工厂模式简单demo123456789101112131415161718192021222324class Jquery &#123; constructor(selector)&#123; let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i &lt; len; i++) &#123; this[i] = dom[i]; &#125; this.length = len; this.selector = selector || ""; &#125; append(node)&#123; &#125; addClass(name)&#123; &#125; html(data)&#123; &#125;&#125;window.$ = function (selector) &#123; return new Jquery(selector);&#125; 2 React.createElement简单demo123456class VNode (tag, attrs, children) &#123; // 此处写法便于理解，语法错误请忽略 // 省略内部代码&#125;React.createElement = function (tag, attrs, children) &#123; return new Vnode(tag, attrs, children);&#125; 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-单列模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是单例设计模式 系统中被唯一使用 一个类中只有一个实例 属于三大设计类型中的创建型模式 UML 类图 示例 登录框 购物车 说明 单例模式需要用到Java的特性 (private) ES6中没有（ typeScript除外） 只能用Java代码来演示 UML 图中的内容 （不要担心，JS中也会变相的实现单例模式）Java代码演示 (Java代码是最容易理解的编程语言之一）12345678910111213141516171819public class SingleObject &#123; // 注意，私有化构造函数，外部不能 new, 只能内部 new！！！！ private SingleObejct()&#123; &#125; // 唯一被 new 出来的对象 private SingleObject instance = null; // 获取对象的唯一接口 public static SingleObject getInstance() &#123; if(instance == null)&#123; // 只 new一次 instance = new SingleObject(); &#125; return instance; &#125; // 对象方法 public void login(username, password) &#123; System.out.println("login..."); &#125;&#125; 1234567891011public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; // 不合适的构造函数 // 编译时错误， 构造函数 SingleObject 是不可见的。 // SingleObject object = new SingleObject(); // 获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); object.login(); &#125;&#125; JS中使用单例模式12345678910111213141516171819202122232425class SingleObject &#123; login() &#123; console.log("login..."): &#125;&#125;SingleObject.getInstance = (function () &#123; let instance; return function () &#123; if(!instance) &#123; instance = new SingleObject(); &#125; return instance; &#125;&#125;)()// 测试，注意这里只能使用静态函数 getInstance, 不能 new SingleObject() !!!let obj1 = SingleObject.getInstance()obj1.login();let obj2 = SingleObject.getInstance()obj2.login();console.log(obj1 === obj2) // true 两者必须完全相等 // 区分let obj3 = new SingleObejct();console.log(obj1 === obj3); // false 这里就不是单例模式了。 场景Jquery 只有一个$模拟登录框其他 Jquery $ Demo 代码可能不一样，但是思路是一样的。12345if (window.Jquery !== null )&#123; return window.Jquery;&#125;else&#123; // 初始化.... &#125; 模拟登录框12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show() &#123; if (this.state === 'show') &#123; alert('已经显示') return &#125; this.state = 'show' console.log('登录框已显示') &#125; hide() &#123; if (this.state === 'hide') &#123; alert('已经隐藏') return &#125; this.state = 'hide' console.log('登录框已隐藏') &#125;&#125;LoginForm.getInstance = (function () &#123; let instance return function () &#123; if (!instance) &#123; instance = new LoginForm(); &#125; return instance &#125;&#125;)()// 一个页面中调用登录框let login1 = LoginForm.getInstance()login1.show()// login1.hide()// 另一个页面中调用登录框let login2 = LoginForm.getInstance()login2.show()// 两者是否相等console.log('login1 === login2', login1 === login2) 其他购物车（和登录框类似）vuex 和 redux 中的 store 设计原则验证 （五大设计原则SOLID） 符合单一职责原则，只实例化唯一的对象。 没法具体体验开放封闭原则，但是绝对不违反开放封闭原则。 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
