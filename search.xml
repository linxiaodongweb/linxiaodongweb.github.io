<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS设计模式-工厂模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式介绍什么是工厂模式工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛 ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。属于三大设计类型中的创建型模式。 什么时候用工厂模式，使用场景等？ 将 new 操作单独封装 遇到 new 时，就要考虑是否该使用工厂模式。 示例 你去购买汉堡，直接点餐，取餐，不用自己亲手做。 商店要 ”封装” 做汉堡的工作，做好直接给买者。 工厂模式UML类图如下其中Creator是一个工厂，Product 是一个产品。一个Creator工厂有一个create方法，返回一个产品，可以理解为最简单的工厂模式。 代码演示1234567891011121314151617181920212223242526272829class Product &#123; constructor(name) &#123; this.name = name; &#125; init() &#123; alert("init"); &#125; fn1() &#123; alert("fn1"); &#125; fn2() &#123; alert("fn2"); &#125; &#125;class Creator &#123; create(name)&#123; return new Product(name); &#125;&#125;// 测试let creator = new Creator();let p = creator.create("p1");p.init();p.fn1();// 结果 弹出 init 111 结论： 我们通过Creator类提供的create方法来创建Product， 通过Creator工厂已经把真正的构造函数封装起来了，我们用的时候只需要知道Creator工厂的create方法可以产生一个实例，而不用去关心生成的实例是谁。 常见场景 Jquery - $(“div”) React.createElement Vue 异步组件 1 Jquery工厂模式简单demo123456789101112131415161718192021222324class Jquery &#123; constructor(selector)&#123; let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i &lt; len; i++) &#123; this[i] = dom[i]; &#125; this.length = len; this.selector = selector || ""; &#125; append(node)&#123; &#125; addClass(name)&#123; &#125; html(data)&#123; &#125;&#125;window.$ = function (selector) &#123; return new Jquery(selector);&#125; 2 React.createElement简单demo123456class VNode (tag, attrs, children) &#123; // 此处写法便于理解，语法错误请忽略 // 省略内部代码&#125;React.createElement = function (tag, attrs, children) &#123; return new Vnode(tag, attrs, children);&#125; 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-单列模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[#单例模式介绍 什么是单例设计模式 系统中被唯一使用 一个类中只有一个实例 属于三大设计类型中的创建型模式 UML 类图 #示例 登录框 购物车 说明 单例模式需要用到Java的特性 (private) ES6中没有（ typeScript除外） 只能用Java代码来演示 UML 图中的内容 （不要担心，JS中也会变相的实现单例模式）Java代码演示 (Java代码是最容易理解的编程语言之一）12345678910111213141516171819public class SingleObject &#123; // 注意，私有化构造函数，外部不能 new, 只能内部 new！！！！ private SingleObejct()&#123; &#125; // 唯一被 new 出来的对象 private SingleObject instance = null; // 获取对象的唯一接口 public static SingleObject getInstance() &#123; if(instance == null)&#123; // 只 new一次 instance = new SingleObject(); &#125; return instance; &#125; // 对象方法 public void login(username, password) &#123; System.out.println("login..."); &#125;&#125; 1234567891011public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; // 不合适的构造函数 // 编译时错误， 构造函数 SingleObject 是不可见的。 // SingleObject object = new SingleObject(); // 获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); object.login(); &#125;&#125; JS中使用单例模式12345678910111213141516171819202122232425class SingleObject &#123; login() &#123; console.log("login..."): &#125;&#125;SingleObject.getInstance = (function () &#123; let instance; return function () &#123; if(!instance) &#123; instance = new SingleObject(); &#125; return instance; &#125;&#125;)()// 测试，注意这里只能使用静态函数 getInstance, 不能 new SingleObject() !!!let obj1 = SingleObject.getInstance()obj1.login();let obj2 = SingleObject.getInstance()obj2.login();console.log(obj1 === obj2) // true 两者必须完全相等 // 区分let obj3 = new SingleObejct();console.log(obj1 === obj3); // false 这里就不是单例模式了。 场景Jquery 只有一个$模拟登录框其他 Jquery $ Demo 代码可能不一样，但是思路是一样的。12345if (window.Jquery !== null )&#123; return window.Jquery;&#125;else&#123; // 初始化.... &#125; 模拟登录框12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show() &#123; if (this.state === 'show') &#123; alert('已经显示') return &#125; this.state = 'show' console.log('登录框已显示') &#125; hide() &#123; if (this.state === 'hide') &#123; alert('已经隐藏') return &#125; this.state = 'hide' console.log('登录框已隐藏') &#125;&#125;LoginForm.getInstance = (function () &#123; let instance return function () &#123; if (!instance) &#123; instance = new LoginForm(); &#125; return instance &#125;&#125;)()// 一个页面中调用登录框let login1 = LoginForm.getInstance()login1.show()// login1.hide()// 另一个页面中调用登录框let login2 = LoginForm.getInstance()login2.show()// 两者是否相等console.log('login1 === login2', login1 === login2) 其他购物车（和登录框类似）vuex 和 redux 中的 store 设计原则验证 （五大设计原则SOLID） 符合单一职责原则，只实例化唯一的对象。 没法具体体验开放封闭原则，但是绝对不违反开放封闭原则。 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
