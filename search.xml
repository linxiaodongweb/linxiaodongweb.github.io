<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS设计模式-外观模式]]></title>
    <url>%2F2019%2F03%2F12%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是外观模式 本段内容来自于 JAdam博客 有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。 其实本篇要说的这个设计模式就和这很有关系，由于当投资者自己买股票时，由于众多投资者对众多股票的联系太多，反而不利于操作，这在软件中就成为耦合性太高，而有了基金后，就变成众多用户只和基金打交道，关心基金的上涨和下跌，而实际上的操作确是基金经理人与股票和其它投资产品打交道，这就是外观模式。 介绍 为子系统中的一组接口提供了一个高级接口 使用者使用这个高级接口看完后应该有一点印象，在看看这张图片就理解了如果没有这个高级接口，我们的代码链接可能很混乱难维护。外观模式在结合业务的场景中很常用。UML类图场景下面的列子就是一种简单的外观模式1234567891011function bindEvent(elem, type, selector, fn) &#123; if ( fn == null) &#123; fn = selector selector = null &#125; // *****&#125;// 调用bindEvent(elem, 'click', '#div1', fn)bindEvent(elem, 'click', fn) 设计原则验证不符合单一职责原则和开放封闭原则，因此要注意谨慎使用，不可滥用 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-代理模式]]></title>
    <url>%2F2019%2F03%2F09%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 使用者无权访问目标对象 中间加代理，通过代理做授权和控制比如说公司的内网，当我们在家的时候也是需要一个代理才能连接访问内网的信息。示例 科学上网，访问 github.com 明星的经纪人 （大多数情况下咱们不可能直接联系明星） UML类图代码说明12345678910111213141516171819202122232425class ReadImg &#123; constructor(filename) &#123; this.filename = filename; this.loadFromDisk() //初始化即从硬盘中加载， 模拟 &#125; display() &#123; console.log('display... ' + this.filename); &#125; loadFromDisk() &#123; console.log('loading... ' + this.filename); &#125;&#125;class ProxyImg &#123; constructor(filename)&#123; this.realImg = new ReadImg(filename); &#125; display() &#123; this.realImg.display(); &#125;&#125;// testlet proxyImg = new ProxyImg("1.png");proxyImg.display(); 场景 网页事件代理(事件委托） Jquery $.proxy ES6 Proxy事件委托代码实现123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;前端设计模式 - 代理模式&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;aaa&lt;/p&gt; &lt;p&gt;bbb&lt;/p&gt; &lt;p&gt;ccc&lt;/p&gt; &lt;p&gt;ddd&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; const appDom = document.querySelector("#app"); appDom.addEventListener("click", (e)=&gt;&#123; const target = e.target; if(target.nodeName="P")&#123; console.log(target,target.innerHTML) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; $.proxy本示例不考虑es6箭头函数解决this指向问题，假设我们维护的还是一个用Jquery的老项目。1234567891011121314//正常的this使用$('#myElement').click(function() &#123; // 这个this是我们所期望的，当前元素的this. $(this).addClass('aNewClass');&#125;);//并非所期望的this$('#myElement').click(function() &#123; setTimeout(function() &#123; // 这个this指向的是settimeout函数内部，而非之前的html元素 $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 这时候通常做法是这样的1234567$('#myElement').click(function() &#123; var that = this; //设置一个变量，指向这个需要的this setTimeout(function() &#123; // 这个this指向的是settimeout函数内部，而非之前的html元素 $(that).addClass('aNewClass'); &#125;, 1000);&#125;); 但是，在使用了jquery框架的情况下， 有一种更好的方式，就是使用$.proxy函数。 jQuery.proxy(),接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context )语境。上面的例子使用这种方式就可以修改成:12345$('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); 明星经纪人1234567891011121314151617181920212223242526272829303132333435363738394041424344// 明星let star = &#123; // name和age可以返回，点化就需要经纪人代理给拦截了。 name: '张XX', age: 25, phone: '13910733521'&#125;// 经纪人let agent = new Proxy(star, &#123; get: function (target, key) &#123; if (key === 'phone') &#123; // 返回经纪人自己的手机号 return '18611112222' &#125; if (key === 'price') &#123; // 明星不报价，经纪人报价 return 120000 &#125; return target[key] &#125;, set: function (target, key, val) &#123; if (key === 'customPrice') &#123; if (val &lt; 100000) &#123; // 最低 10w throw new Error('价格太低') &#125; else &#123; target[key] = val return true &#125; &#125; &#125;&#125;)// 主办方去找明星的经纪人console.log(agent.name) // 经纪人返回明星的姓名console.log(agent.age) // 明星的姓名console.log(agent.phone) // 经纪人的点化，经纪人拦截了phone。console.log(agent.price) // 明星搞艺术，不谈钱，经纪人谈钱。// 想自己提供报价（砍价，或者高价争抢）agent.customPrice = 150000// agent.customPrice = 90000 // 报错：价格太低console.log('customPrice', agent.customPrice) 设计原则验证 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则代理模式 VS 适配器模式 适配器模式： 提供一个不同的接口（比如不同版本的插座插口) 代理模式： 提供一模一样的接口代理模式 VS 装饰器模式 装饰器模式： 扩展功能，原有功能不变且可直接使用，扩展功能不冲突原有功能。 代理模式： 显示原有功能，但是经过限制或者阉割之后的 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程。 $.proxy 代码部分来自于浪漫小生博客]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-装饰器模式]]></title>
    <url>%2F2019%2F03%2F07%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍 为对象添加新功能 不改变其原有的结构和功能和适配器模式不一样，适配器模式是原有的不能用了，而装饰器模式是原来的还能用，不过给增加一些功能。比如： 手机壳，用来给手机美观，保护，防滑等等 UML类图 代码演示123456789101112131415161718192021222324class Circle &#123; draw() &#123; console.log("画一个圆形"); &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle; &#125; draw() &#123; this.circle.draw(); this.setRedBorder(this.circle); &#125; setRedBorder(circle) &#123; console.log("设置红色边框") &#125;&#125;// 测试代码let circle = new Circle();circle.draw()let dec = new Decorator(circle);dec.setRedBorder(); 场景 ES7装饰器-babel可转换 core-decorators等第三方库常用装饰器ES7装饰器装饰类一个简单的demo123456789// 一个简单的demofunction testDec(target) &#123; target.isDec = "林海"&#125;@testDecclass Demo &#123;&#125;alert(Demo.isDec) 装饰类的原理12345678// 装饰器的原理@decoratorclass A &#123;&#125;//等同于class A &#123;&#125;A = decorator(A) || A; 可以加参数12345678910function testDec(isDec) &#123; return function(target)&#123; target.isDec = isDec; &#125;&#125;@testDec(true)class Demo &#123;&#125;alert(Demo.isDec) 我们来做一个常用的mixins混合装饰器，来把一个类里面属性和方法全部添加到另一个类上123456789101112131415function mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125; &#125; const Foo = &#123; foo() &#123; alert('foo') &#125; &#125; @mixins(Foo) class MyClass &#123;&#125; let obj = new MyClass(); obj.foo() // 'foo' 装饰方法让某个方法只读，不能修改1234567891011121314151617181920212223242526function readonly(target, name, descriptor)&#123; // descriptor属性描述对象 （Object.defineProperty 会用到) // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor; &#125; class Person &#123; constructor() &#123; this.first = 'A' this.last = 'B' &#125; @readonly testname() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125; &#125; var p = new Person() console.log(p.testname()) p.testname = function () &#123;&#125; // 这里会报错，因为 name 是只读属性 一个打印日志装饰器123456789101112131415161718192021function log(target, name, descriptor) &#123; var oldValue = descriptor.value; // name 是修饰的方法名字 descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor; &#125; class Math &#123; @log add(a, b) &#123; return a + b; &#125; &#125; const math = new Math(); const result = math.add(2, 4); console.log('result', result); 装饰类的时候，一般主要是看target（装饰对象）第一个参数。装饰方法的时候，一般主要看的是descriptor（描述）第三个参数。 core-decorators 第三方开源 lib 提供常用的装饰器,比如readonly只读状态,autobind绑定this等 查阅文档： https://github.com/jayphelps/core-decorators 12// 首先安装npm install core-decorators --save 这里我们使用 core-decorators提供的deprecate(对装饰的方法在浏览器中提示已经废弃） 12345678910111213141516171819202122232425import &#123; deprecate &#125; from 'core-decorators';class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate('We stopped facepalming') facepalmHard() &#123;&#125; @deprecate('We stopped facepalming', &#123; url: 'http://knowyourmeme.com/memes/facepalm' &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details. 运行结果如下图： 设计原则验证 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 对装饰器更多学习，可以看 阮一峰es6装饰器教程 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-适配器模式]]></title>
    <url>%2F2019%2F03%2F05%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是适配器模式 旧接口模式和使用者不兼容 中间加一个适配器转接口比如你去香港或者出国去一些国家，他们的插排接口和我们都不一样，我要充电不能直接用，这个时候就需要一个适配器来转换一下电压。 UML类图代码演示12345678910111213141516171819class Adaptee &#123; specificRequest() &#123; return "德国标准插头"; &#125;&#125;class Target &#123; constructor() &#123; this.adaptee = new Adaptee() &#125; request() &#123; let info = this.adaptee.specificRequest(); return `$&#123;info&#125; - 转换器 - 中国插头` &#125;&#125;// 测试let target = new Target();let res = target.request();console.log(res); 场景 封装旧接口 vue computed封装旧接口123456789101112// 自己封装的 ajax 使用方法如下ajax(&#123; url: '/getData', type: 'post', dataType: 'json', data: &#123; id: "123" &#125;&#125;).done(function()&#123;&#125;)// 但因为历史原因，代码中全都是：// $.ajax(&#123;...&#125;) 如果这时候不适用jquery了，手动去一个个替换$.ajax不靠谱，旧接口不兼容，这时候我们只需要一个适配器来封装旧接口来实现，而且以后的也还可以继续像Jquery使用123456// 做一层适配器var $ = &#123; ajax: function(options)&#123; return ajax(options); &#125;&#125; vue的计算属性也是一个适配器，这里我拿官网demo来展示下，可以仔细品味下1234567891011121314151617181920&lt;div id="app"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 设计原则验证 将旧接口和使用者进行分离 符合开放封闭原则 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-工厂模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是工厂模式工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。著名的Jive论坛 ,就大量使用了工厂模式，工厂模式在Java程序系统可以说是随处可见。因为工厂模式就相当于创建实例对象的new，我们经常要根据类Class生成实例对象，如A a=new A() 工厂模式也是用来创建实例对象的，所以以后new时就要多个心眼，是否可以考虑使用工厂模式，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。属于三大设计类型中的创建型模式。 什么时候用工厂模式，使用场景等？ 将 new 操作单独封装 遇到 new 时，就要考虑是否该使用工厂模式。 示例 你去购买汉堡，直接点餐，取餐，不用自己亲手做。 商店要 ”封装” 做汉堡的工作，做好直接给买者。 工厂模式UML类图如下其中Creator是一个工厂，Product 是一个产品。一个Creator工厂有一个create方法，返回一个产品，可以理解为最简单的工厂模式。 代码演示1234567891011121314151617181920212223242526272829class Product &#123; constructor(name) &#123; this.name = name; &#125; init() &#123; alert("init"); &#125; fn1() &#123; alert("fn1"); &#125; fn2() &#123; alert("fn2"); &#125; &#125;class Creator &#123; create(name)&#123; return new Product(name); &#125;&#125;// 测试let creator = new Creator();let p = creator.create("p1");p.init();p.fn1();// 结果 弹出 init 111 结论： 我们通过Creator类提供的create方法来创建Product， 通过Creator工厂已经把真正的构造函数封装起来了，我们用的时候只需要知道Creator工厂的create方法可以产生一个实例，而不用去关心生成的实例是谁。 常见场景 Jquery - $(“div”) React.createElement Vue 异步组件 1 Jquery工厂模式简单demo123456789101112131415161718192021222324class Jquery &#123; constructor(selector)&#123; let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i &lt; len; i++) &#123; this[i] = dom[i]; &#125; this.length = len; this.selector = selector || ""; &#125; append(node)&#123; &#125; addClass(name)&#123; &#125; html(data)&#123; &#125;&#125;window.$ = function (selector) &#123; return new Jquery(selector);&#125; 2 React.createElement简单demo123456class VNode (tag, attrs, children) &#123; // 此处写法便于理解，语法错误请忽略 // 省略内部代码&#125;React.createElement = function (tag, attrs, children) &#123; return new Vnode(tag, attrs, children);&#125; 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS设计模式-单列模式]]></title>
    <url>%2F2019%2F03%2F02%2FJS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E5%88%97%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是单例设计模式 系统中被唯一使用 一个类中只有一个实例 属于三大设计类型中的创建型模式 UML 类图 示例 登录框 购物车 说明 单例模式需要用到Java的特性 (private) ES6中没有（ typeScript除外） 只能用Java代码来演示 UML 图中的内容 （不要担心，JS中也会变相的实现单例模式）Java代码演示 (Java代码是最容易理解的编程语言之一）12345678910111213141516171819public class SingleObject &#123; // 注意，私有化构造函数，外部不能 new, 只能内部 new！！！！ private SingleObejct()&#123; &#125; // 唯一被 new 出来的对象 private SingleObject instance = null; // 获取对象的唯一接口 public static SingleObject getInstance() &#123; if(instance == null)&#123; // 只 new一次 instance = new SingleObject(); &#125; return instance; &#125; // 对象方法 public void login(username, password) &#123; System.out.println("login..."); &#125;&#125; 1234567891011public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; // 不合适的构造函数 // 编译时错误， 构造函数 SingleObject 是不可见的。 // SingleObject object = new SingleObject(); // 获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); object.login(); &#125;&#125; JS中使用单例模式12345678910111213141516171819202122232425class SingleObject &#123; login() &#123; console.log("login..."): &#125;&#125;SingleObject.getInstance = (function () &#123; let instance; return function () &#123; if(!instance) &#123; instance = new SingleObject(); &#125; return instance; &#125;&#125;)()// 测试，注意这里只能使用静态函数 getInstance, 不能 new SingleObject() !!!let obj1 = SingleObject.getInstance()obj1.login();let obj2 = SingleObject.getInstance()obj2.login();console.log(obj1 === obj2) // true 两者必须完全相等 // 区分let obj3 = new SingleObejct();console.log(obj1 === obj3); // false 这里就不是单例模式了。 场景Jquery 只有一个$模拟登录框其他 Jquery $ Demo 代码可能不一样，但是思路是一样的。12345if (window.Jquery !== null )&#123; return window.Jquery;&#125;else&#123; // 初始化.... &#125; 模拟登录框12345678910111213141516171819202122232425262728293031323334353637383940414243class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show() &#123; if (this.state === 'show') &#123; alert('已经显示') return &#125; this.state = 'show' console.log('登录框已显示') &#125; hide() &#123; if (this.state === 'hide') &#123; alert('已经隐藏') return &#125; this.state = 'hide' console.log('登录框已隐藏') &#125;&#125;LoginForm.getInstance = (function () &#123; let instance return function () &#123; if (!instance) &#123; instance = new LoginForm(); &#125; return instance &#125;&#125;)()// 一个页面中调用登录框let login1 = LoginForm.getInstance()login1.show()// login1.hide()// 另一个页面中调用登录框let login2 = LoginForm.getInstance()login2.show()// 两者是否相等console.log('login1 === login2', login1 === login2) 其他购物车（和登录框类似）vuex 和 redux 中的 store 设计原则验证 （五大设计原则SOLID） 符合单一职责原则，只实例化唯一的对象。 没法具体体验开放封闭原则，但是绝对不违反开放封闭原则。 本文资料来自慕课网-双越老师-Javascript 设计模式系统讲解与应用视频课程]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
